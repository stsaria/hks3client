<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Sketch Viewer</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  canvas { cursor: crosshair; background-color:#f9f9f9; }
  progress::-webkit-progress-bar { background-color:#e5e7eb; border-radius:0.25rem; }
  progress::-webkit-progress-value { background-color:#22c55e; border-radius:0.25rem; }
  progress::-moz-progress-bar { background-color:#22c55e; border-radius:0.25rem; }
</style>
</head>
<body class="bg-gray-100 flex flex-col items-center p-4">

<div class="w-full max-w-5xl bg-white shadow rounded p-4 mb-4">
  <h2 class="text-2xl font-bold mb-4">Sketch Viewer</h2>

  <!-- サーバー接続 -->
  <div class="flex flex-wrap items-center gap-4 mb-4">
    <input id="serverInput" type="text" value="http://127.0.0.1:8080" class="border rounded px-2 py-1 flex-1">
    <button onclick="setServer()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-1 rounded shadow">接続</button>
    <div id="rights" class="text-gray-700 font-medium">権利: -</div>
  </div>

  <!-- カラーパレット -->
  <div class="flex items-center gap-4 mb-4">
    <label class="flex items-center gap-2">
      色: <input type="color" id="colorPicker" value="#ff0000" class="w-10 h-10 border rounded">
    </label>
    <div id="palette" class="grid grid-cols-8 gap-2"></div>
  </div>

  <!-- キャンバス -->
  <div class="mb-2 relative">
    <canvas id="sketchCanvas" width="800" height="800" class="border rounded shadow"></canvas>
  </div>

  <!-- 操作パネル -->
  <div class="flex items-center gap-4 mt-2">
    <div id="coords" class="text-gray-700 font-medium">座標: -, -</div>
    <button onclick="downloadJson()" class="bg-green-500 hover:bg-green-600 text-white px-4 py-1 rounded shadow">
      JSONダウンロード
    </button>
  </div>
</div>

<script>
const canvas = document.getElementById("sketchCanvas");
const ctx = canvas.getContext("2d");
const coordsDiv = document.getElementById("coords");
const rightsDiv = document.getElementById("rights");
const colorPicker = document.getElementById("colorPicker");
const paletteDiv = document.getElementById("palette");

let serverUrl = "";
let sketchData = {};
let sketchRange = {x:800, y:800};
let scale = 1.0, minScale = 0.2;
let offsetX = 0, offsetY = 0;
let isDragging = false, lastMouseX, lastMouseY;

// パレット生成
const paletteColors = ["#ff0000","#00ff00","#0000ff","#ffff00","#ff00ff","#00ffff","#ffffff","#000000"];
paletteColors.forEach(c=>{
  const btn=document.createElement("button");
  btn.style.background=c;
  btn.className="w-6 h-6 rounded border";
  btn.addEventListener("click",()=> colorPicker.value=c);
  paletteDiv.appendChild(btn);
});

// サーバー設定
function setServer(){
  serverUrl = document.getElementById("serverInput").value;
  getSketchRange();
  getCompactSketch();
  getRights();
  startAutoUpdate(1000); // 接続後に1秒ごとの自動更新開始
}

// スケッチ取得
async function getCompactSketch(){
  try{
    const res = await fetch(`${serverUrl}/getCompactSketch`);
    const data = await res.json();
    if(data.status.id===0){
      sketchData={};
      for(const key in data.c){
        const [r,g,b] = data.c[key];
        sketchData[key]=`rgb(${r},${g},${b})`;
      }
      drawSketch();
    }
  }catch(err){console.error(err);}
}

// 権利取得
async function getRights(){
  try{
    const res = await fetch(`${serverUrl}/getRights`);
    const data = await res.json();
    if(data.status.id===0) rightsDiv.innerText="権利: "+data.c;
  }catch(err){console.error(err);}
}

// スケッチ範囲取得
async function getSketchRange(){
  try{
    const res = await fetch(`${serverUrl}/getSketchRange`);
    const data = await res.json();
    if(data.status.id===0){
      sketchRange=data.c;
      canvas.width=sketchRange.x;
      canvas.height=sketchRange.y;
      drawSketch();
    }
  }catch(err){console.error(err);}
}

// キャンバス描画
function drawSketch(){
  ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
  ctx.clearRect(-offsetX/scale,-offsetY/scale,canvas.width/scale,canvas.height/scale);
  for(const key in sketchData){
    const [x,y]=key.split(",").map(Number);
    ctx.fillStyle=sketchData[key];
    ctx.fillRect(x,y,1,1);
  }
  ctx.strokeStyle="#000";
  ctx.lineWidth=1/scale;
  ctx.strokeRect(0,0,sketchRange.x,sketchRange.y);
}

// ズーム
canvas.addEventListener("wheel", e=>{
  e.preventDefault();
  const zoomFactor=1.1;
  const mouseX=e.offsetX, mouseY=e.offsetY;
  const prevScale=scale;
  scale=e.deltaY<0?scale*zoomFactor:scale/zoomFactor;
  scale=Math.max(scale,minScale);
  offsetX=mouseX-(mouseX-offsetX)*(scale/prevScale);
  offsetY=mouseY-(mouseY-offsetY)*(scale/prevScale);
  drawSketch();
});

// 右クリック移動
canvas.addEventListener("contextmenu", e=>e.preventDefault());
canvas.addEventListener("mousedown", e=>{
  if(e.button===2){isDragging=true; lastMouseX=e.clientX; lastMouseY=e.clientY;}
});
canvas.addEventListener("mouseup", e=>{if(e.button===2) isDragging=false;});
canvas.addEventListener("mousemove", e=>{
  if(isDragging){offsetX+=e.clientX-lastMouseX; offsetY+=e.clientY-lastMouseY; lastMouseX=e.clientX; lastMouseY=e.clientY; drawSketch();}
  const canvasX=Math.floor((e.offsetX-offsetX)/scale);
  const canvasY=Math.floor((e.offsetY-offsetY)/scale);
  coordsDiv.innerText=`座標: ${Math.max(0,Math.min(canvasX,sketchRange.x-1))}, ${Math.max(0,Math.min(canvasY,sketchRange.y-1))}`;
});

// 左クリックペイント / Shiftでスポイト
canvas.addEventListener("click", async e=>{
  const canvasX=Math.floor((e.offsetX-offsetX)/scale);
  const canvasY=Math.floor((e.offsetY-offsetY)/scale);
  const boundedX=Math.max(0,Math.min(canvasX,sketchRange.x-1));
  const boundedY=Math.max(0,Math.min(canvasY,sketchRange.y-1));

  if(e.shiftKey){
    const key=`${boundedX},${boundedY}`;
    if(sketchData[key]) colorPicker.value=rgbToHex(sketchData[key]);
    return;
  }

  const hex=colorPicker.value;
  const r=parseInt(hex.substr(1,2),16);
  const g=parseInt(hex.substr(3,2),16);
  const b=parseInt(hex.substr(5,2),16);

  try{
    const res=await fetch(`${serverUrl}/paint?x=${boundedX}&y=${boundedY}&r=${r}&g=${g}&b=${b}`);
    const data=await res.json();
    if(data.status.id===0){ await getCompactSketch(); await getRights(); }
    else alert(data.status.description);
  }catch(err){ console.error(err);}
});

function rgbToHex(rgb){
  const result=rgb.match(/\d+/g);
  if(!result) return "#000000";
  return "#" + result.map(x=>("0"+parseInt(x).toString(16)).padStart(2,"0")).join("");
}

// JSONダウンロード処理
async function downloadJson(){
  try {
    const rangeRes = await fetch(`${serverUrl}/getSketchRange`);
    const rangeData = await rangeRes.json();
    if(rangeData.status.id !== 0) throw new Error("Failed to get sketch range");

    const historyRes = await fetch(`${serverUrl}/getHistory`);
    const historyData = await historyRes.json();
    if(historyData.status.id !== 0) throw new Error("Failed to get history");

    const exportData = {
      range: rangeData.c,
      history: historyData.c
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "sketch_history.json";
    a.click();
    URL.revokeObjectURL(url);
  } catch (err){
    console.error(err);
    alert("JSONダウンロードに失敗しました");
  }
}

// 自動更新処理
function startAutoUpdate(intervalMs = 1000) {
  if (window.autoUpdateTimer) clearInterval(window.autoUpdateTimer);
  window.autoUpdateTimer = setInterval(async () => {
    if (!serverUrl) return;
    await getCompactSketch();
    await getRights();
  }, intervalMs);
}
</script>
</body>
</html>

